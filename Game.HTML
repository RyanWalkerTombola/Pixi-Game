<!DOCTYPE html>
<html>

<head>
    <title>Kerbz</title>
    <script src="Pixi/pixi.min.js" type="text/javascript"></script>
</head>

<body>
    <style>
        * {
            padding: 0;
            margin: 0;
            overflow: hidden
        }
    </style>
    <!-- <script src="main.js" type="text/javascript"></script> -->
    <script>
        // -----------------------------------------------======== Classes ========----------------------------------------------- //

        class Vector {
            static zero = new Vector(0, 0);
            static one = new Vector(1, 1);
            static half = new Vector(0.5, 0.5);

            static up = new Vector(0, 1);
            static right = new Vector(1, 0);
            static down = new Vector(0, -1);
            static left = new Vector(-1, 0);

            constructor(x, y) {
                this.x = x;
                this.y = y;
            }

            // Returns the magnitude of the vector
            magnitude() {
                    return Math.sqrt(this.x * this.x + this.y * this.y);
                }
                // Returns the normalized vector (direction)
            normalized() {
                var magnitude = this.magnitude();
                if (magnitude != 0)
                    return new Vector(this.x / magnitude, this.y / magnitude);
                else
                    return 0;
            }
            floor() {
                return new Vector(Math.floor(this.x), Math.floor(this.y));
            }
            clamp(minX, minY, maxX, maxY) {
                return new Vector(clamp(this.x, minX, maxX), clamp(this.y, minY, maxY));
            }

            // Caluclates the distance from one vector to another and returns a vector
            distanceTo(target) {
                    if (typeof target === 'object') {
                        target = new Vector(target.x, target.y);
                    }
                    return new Vector(target.x - this.x, target.y - this.y)
                }
                // Calculates the direction to another vector and returns a normalized vector
            directionTo(target) {
                    if (typeof target === 'object') {
                        target = new Vector(target.x, target.y);
                    }
                    return this.distanceTo(target).normalized();
                }
                // Returns the distace to the target as a float (non directional)
            distance(target) {
                if (typeof target === 'object') {
                    target = new Vector(target.x, target.y);
                }
                return this.distanceTo(target).magnitude();
            }

            // Takes two vectors and returns their sum
            add(value) {
                    if (typeof value === 'number') {
                        value = new Vector(value, value)
                    }
                    return new Vector(this.x + value.x, this.y + value.y);
                }
                // Takes two vectors and subtracts one from the other
            subtract(value) {
                    if (typeof value === 'number') {
                        value = new Vector(value, value)
                    }
                    return new Vector(this.x - value.x, this.y - value.y);
                }
                // Takes two vectors and returns their product
            multiply(value) {
                    if (typeof value === 'number') {
                        value = new Vector(value, value)
                    }
                    return new Vector(this.x * value.x, this.y * value.y);
                }
                // Divides a vetor by by another and returns a vector
            divide(value) {
                if (typeof value === 'number') {
                    value = new Vector(value, value)
                }
                if (value.x != 0 && value.y != 0)
                    return new Vector(this.x / value.x, this.y / value.y);
                else
                    return value.zero;
            }

            // Converts an angle in radians to a vector
            radToVector(value) {
                    return new Vector(Math.cos(value), Math.sin(value));
                }
                // Converts a vector to an angle in radians
            toRad() {
                return Math.atan2(this.x, this.y);
            }
            toVector(object) {
                return new Vector(object.x, object.y);
            }
            toLocal() {
                return this.add(new Vector(app.stage.pivot.x, app.stage.pivot.y))
            }
            rotate(radians) {
                return new Vector(
                    this.x * Math.cos(radians) - this.y * Math.sin(radians),
                    this.x * Math.sin(radians) + this.y * Math.cos(radians)
                );
            }
        }

        class Line extends PIXI.Graphics {
            constructor(points, lineSize, lineColor) {
                super();

                var s = this.lineWidth = lineSize || 5;
                var c = this.lineColor = lineColor || "0x000000";

                this.points = points;

                this.lineStyle(s, c)

                this.moveTo(points[0].x, points[0].y);
                this.lineTo(points[1].x, points[1].y);
            }

            updatePoints(p) {
                var points = this.points = p.map((val, index) => val || this.points[index]);

                var s = this.lineWidth;
                var c = this.lineColor;

                this.clear();


                for (let i = 0; i < points.length - 1; i++) {
                    this.lineStyle(s, c, lerp(0.8, 0, i / (points.length - 1)));
                    this.moveTo(points[i].x, points[i].y);
                    this.lineTo(points[i + 1].x, points[i + 1].y);
                }
            }
        }

        // Attachments is a bool array showing if the object can attach on a certain side [up, right, down, left]

        class Part {
            constructor(spriteName, attachments, mass) {
                this.sprite;
                this.parent;
                this.spriteName = spriteName;
                this.attachments = attachments;
                this.mass = mass;
            }

            addPart(x, y, parent) {
                this.parent = parent;
                this.sprite = new Sprite(id[this.spriteName]);
                this.sprite.position.set(x * 16, y * 16);
                this.parent.addChild(this.sprite);
            }

            removePart() {
                this.parent.removeChild(this.sprite);
            }
        }

        class FuelTank extends Part {
            constructor(spriteName, attachments, mass, fuel) {
                super(spriteName, attachments, mass);
                this.fuel = fuel;
            }
        }

        class Engine extends Part {
            constructor(spriteName, attachments, mass, thrust) {
                super(spriteName, attachments, mass);
                this.thrust = thrust;
            }
        }

        class Cabin extends Part {
            constructor(spriteName, attachments, mass) {
                super(spriteName, attachments, mass);
            }
        }

        class Rocket {
            constructor(x, y, width, height) {
                this.container = new Container();

                this.parts = [
                    [width],
                    [height]
                ];
                this.parts = [...Array(width)].map(e => Array(height).fill(undefined));

                this.mass;
                this.COM;
                this.fuel;
                this.fuelMax;
                this.thrust;

                this.position = new Vector(x, y);
                this.rotation = 0.5;
                this.velocity = Vector.zero;
                this.angularVelocity;
                this.scale = 0.5;

                this.move();
            }

            move() {
                this.position.add(this.velocity);
                this.container.position.set(this.position.x, this.position.y);
                this.container.rotation = this.rotation;
                this.container.scale.set(this.scale);
            }

            placePart(part, x, y) {
                if (x < 0 || y < 0 || x >= this.parts.length || y >= this.parts[x].length) {
                    return;
                }
                if (this.parts[x][y] === undefined) {
                    this.parts[x][y] = Object.assign(new part.constructor, part);
                    this.parts[x][y].addPart(x, y, this.container);
                } else {
                    this.parts[x][y].removePart();
                    this.parts[x][y] = undefined;
                }
                this.calculateProperties();
            }

            calculateProperties() {
                this.mass = 0;
                this.fuel = 0;
                this.thrust = 0;

                this.parts.map(y => y.map(part => {
                    if (part !== undefined) {
                        this.mass += part.mass;

                        if (part.constructor.name === 'FuelTank') {
                            this.fuel += part.fuel;
                            this.fuelMax = this.fuel;
                        } else if (part.constructor.name === 'Engine') {
                            this.thrust += part.thrust;
                        }
                    }
                }));

                let mx = 0,
                    my = 0;
                for (let x = 0; x < this.parts.length; x++) {
                    for (let y = 0; y < this.parts[0].length; y++) {
                        const part = this.parts[x][y];
                        if (part !== undefined) {
                            mx += part.mass * x;
                            my += part.mass * y;
                        }
                    }
                }
                this.COM = new Vector(mx / this.mass, my / this.mass);

                // console.clear();
                // console.log(`Mass: ${this.mass} Fuel: ${this.fuel} Thrust: ${this.thrust}`);
                // console.log(`Thrust to Weight: ${this.thrust / this.mass}`);
            }

            worldPos(value) {
                let pos = value.add(0.5).multiply(16 * this.scale);
                return this.position.add(pos.rotate(this.rotation));
            }

            localPos(value) {

                // FIX THIS SHITTT!!!!!!!!

                let pos = value.rotate(-this.rotation).divide(16 * this.scale).divide(8).subtract(this.position.divide(16 * this.scale)) //value.divide(16).subtract(this.position.multiply(this.scale)).multiply(this.scale);
                console.log(pos.floor());
                return pos;

            }

            // checkCollisions() {
            //     this.parts.map(y => y.map(part => {
            //         if (part !== undefined) {
            //             const partPos = Vector.zero.toVector(part).divide(4)
            //             const worldPartPos = position.add(partPos);
            //             if (worldPartPos.distance(planet) <= planet.radius && alive) {
            //                 alive = false;
            //             }
            //         }
            //     }));
            // }

        }

        // -----------------------------------------------======== PIXI ========----------------------------------------------- //

        // Preserves pixels when upscaling
        PIXI.SCALE_MODES.DEFAULT = PIXI.SCALE_MODES.NEAREST;

        // Aliases
        let Application = PIXI.Application,
            loader = PIXI.loader,
            resources = PIXI.loader.resources,
            Sprite = PIXI.Sprite,
            Text = PIXI.Text,
            TextStyle = PIXI.TextStyle;
        Graphics = PIXI.Graphics;
        Container = PIXI.Container;

        // Create a Pixi Application
        let app = new PIXI.Application({
            width: window.innerWidth,
            height: window.innerHeight,
            antialias: true,
            transparent: false,
            resolution: 1,
            forceFXAA: false,
            roundPixels: true
        });

        // Add the canvas to the HTML document
        document.body.appendChild(app.view);

        // Resize the canvas to the full page
        app.renderer.view.style.position = "absolute";
        app.renderer.view.style.display = "block";
        app.renderer.autoResize = true;
        app.renderer.resize(window.innerWidth, window.innerHeight);



        // Load an image and run the setup function when it's done
        PIXI.loader
            .add("Assets/space-spritesheet.json")
            .add("Assets/Launchpad Mockup.png")
            .load(setup);

        let left = keyboard("a"),
            right = keyboard("d"),
            up = keyboard("w"),
            down = keyboard("s");
        keyM = keyboard("m");
        comma = keyboard("q")
        period = keyboard("e");

        window.addEventListener("mousemove", e => {
            worldMousePos = new Vector(e.clientX, e.clientY)
        }, false);
        window.addEventListener("wheel", event => zoom *= 1 + event.deltaY / 5000);

        // -----------------------------------------------======== Setup ========----------------------------------------------- //

        let json;
        let request = new XMLHttpRequest();
        request.open("GET", "Assets/space-spritesheet.json", true);
        request.onload = function() {
            json = JSON.parse(this.response);
        }
        request.send();

        const drag = 0.02,
            rotationSpeed = 0.0005,
            brakingForce = 0.05;

        let vab, spaceShip, ghost, mouseGrid;

        var line, apoapsisIcon, periapsisIcon, heading, headingCircle, fuelBar, collisionCourse = false,
            COMIcon;
        var GUI, velocityText, altitudeText, fuelText, headingText, timeWarpText;
        let state, rocket, alive = true,
            launched, altitude, planet;
        let position, velocity, angularVelocity, zoom = 0.05,
            mapThreshold = 10,
            mapTransition = 10;
        let worldMousePos = Vector.zero,
            localMousePos = Vector.zero;
        let timeWarp = 1,
            timeWarpIndex = 0,
            timeWarps = [1, 2, 5, 10, 50, 100, 500, 1000, 5000, 10000, 50000, 100000];

        let cabin = new Cabin("Space Tilesheet 27.aseprite", [0, 0, 1, 0], 0.1);
        let tank = new FuelTank("Space Tilesheet 28.aseprite", [1, 2, 1, 2], 1, 600);
        let lightweightTank = new FuelTank("Space Tilesheet 28.aseprite", [1, 2, 1, 2], 0.5, 300);
        let engine = new Engine("Space Tilesheet 29.aseprite", [1, 0, 2, 0], 1, 1);
        let partIndex = 0;
        let parts = [cabin, tank, engine];

        let spaceRocket;

        // for (let i = 0; i < spaceRocket.parts[1].length; i++) {
        //     console.log(spaceRocket.parts[1]);
        // }

        // This will run when the image has loaded
        function setup() {
            // Create an alias called id for all the textures
            id = resources["Assets/space-spritesheet.json"].textures;

            let style = new TextStyle({
                fontFamily: "Arial",
                fontSize: 36,
                fill: "white"
            })

            // --- Vehicle Assembley Building --- //

            vab = new Container();
            app.stage.addChild(vab);
            vab.scale.set(8);

            spaceRocket = new Rocket((window.innerWidth / 2 / 8) - 24, 0, 3, 6);
            vab.addChild(spaceRocket.container);
            spaceRocket.placePart(cabin, 1, 1);
            spaceRocket.placePart(tank, 1, 2);
            spaceRocket.placePart(tank, 1, 3);
            spaceRocket.placePart(tank, 1, 4);
            spaceRocket.placePart(engine, 1, 5);


            ghost = new Sprite(id[parts[partIndex].spriteName]);
            spaceRocket.container.addChild(ghost);

            COMIcon = new Graphics();
            COMIcon.beginFill(0xFFFF60).lineStyle(0.5, 0x2a262e).drawCircle(0, 0, 1.4).endFill();
            vab.addChild(COMIcon);

            // --- World Elements --- //

            // World Container
            world = new Container();
            app.stage.addChild(world);

            // Planet
            planet = new Graphics();
            planet.beginFill(0x285cc4);
            planet.lineStyle(10, 0x14a02e);
            planet.drawCircle(0, 0, 63705);
            planet.endFill();
            planet.position.set(0);
            planet.scale.set(10);
            world.addChild(planet);
            planet.radius = planet.width / 2;

            // Launchpad
            let launchpad = new Sprite(resources["Assets/Launchpad Mockup.png"].texture);
            launchpad.anchor.set(0.375, 1);
            launchpad.y = -637100;
            launchpad.scale.set(0.25);
            world.addChild(launchpad);

            // Rocket
            rocket = new Sprite(id["Space Tilesheet 0.aseprite"]);
            rocket.anchor.set(0.5);
            position = new Vector(0, -(637100 + 16));
            velocity = new Vector(0 /*1800 / 60*/ , 0);
            rocket.rotation = 0;
            rocket.frame = 0;
            rocket.lastAnimation = "";
            rocket.scale.set(0.25)
            angularVelocity = 0;
            world.addChild(rocket);

            // --- Map --- //

            // Map Overlay
            map = new Container();
            world.addChild(map)

            // Trajectory Line
            trajectoryLine = new Line([200, 10, 0, 0], 2, "0xffffff");
            map.addChild(trajectoryLine);

            // Apoapsis
            apoapsisIcon = new Sprite(id["Space Tilesheet 20.aseprite"]);
            apoapsisIcon.anchor.set(0.5, 1);
            map.addChild(apoapsisIcon);

            // Periapsis
            periapsisIcon = new Sprite(id["Space Tilesheet 21.aseprite"]);
            periapsisIcon.anchor.set(0.5, 1);
            map.addChild(periapsisIcon);

            // --- GUI --- //

            // GUI Container
            GUI = new Container();
            world.addChild(GUI);

            // Velocity
            velocityText = new Text("Velocity: ", style);
            GUI.addChild(velocityText);
            velocityText.position = new Vector(10, 0);

            // Altitude
            altitudeText = new Text("Altitude: ", style);
            GUI.addChild(altitudeText);
            altitudeText.position = new Vector(10, 50);

            // Fuel
            fuelText = new Text("Fuel: ", style);
            GUI.addChild(fuelText);
            fuelText.position.set(10, 100);

            fuelBar = new PIXI.Container();
            fuelBar.position.set(100, 100);
            GUI.addChild(fuelBar);

            let innerBar = new Graphics();
            innerBar.beginFill(0x555555);
            innerBar.drawRect(0, 0, 200, 40);
            innerBar.endFill();
            fuelBar.addChild(innerBar);

            let outerBar = new PIXI.Graphics();
            outerBar.beginFill(0xFF3300);
            outerBar.drawRect(0, 0, 200, 40);
            outerBar.endFill();
            fuelBar.addChild(outerBar);

            fuelBar.outer = outerBar;

            // Heading
            headingText = new Text("Heading: ", style);
            GUI.addChild(headingText);
            headingText.position.set(10, 160);

            headingCircle = new Graphics();
            headingCircle.beginFill(0xdddddd);
            headingCircle.lineStyle(5, 0x555555);
            headingCircle.drawCircle(0, 0, 20);
            headingCircle.endFill();
            headingCircle.position.set(190, 180);
            GUI.addChild(headingCircle);

            heading = new Line([Vector.zero, Vector.one.multiply(10)], 3, "0xfc5044");
            GUI.addChild(heading);
            heading.position.set(190, 180);

            // Kerb
            kerb = new Sprite(id["Space Tilesheet 22.aseprite"]);
            kerb.anchor.set(0, 1);
            kerb.position.set(10, window.innerHeight - 10);
            kerb.scale.set(8);
            GUI.addChild(kerb);

            // Time Warp text
            timeWarpText = new Text("TimeWarp: ", style);
            GUI.addChild(timeWarpText);
            timeWarpText.anchor.set(0.5);
            timeWarpText.position = new Vector(window.innerWidth / 2, 100);
            timeWarpText.alpha = 0;
            timeWarpText.scale.set(0.5);

            // --- Keys --- //
            //console.log(spaceShip.elements)
            keyM.press = () => {
                if (state.name === "World") {
                    if (zoom > mapThreshold) {
                        zoom = 0.2;
                    } else if (zoom <= mapThreshold) {
                        zoom = 3000;
                    }
                } else {
                    launch()
                }
            }

            up.press = () => {
                if (state.name === "VAB") {
                    let x = mouseGrid.x,
                        y = mouseGrid.y;
                    spaceRocket.placePart(parts[partIndex], x, y);
                }
            }

            comma.press = () => {
                if (state.name === "World") {
                    if (timeWarpIndex > 0) {
                        timeWarpIndex--;
                        timeWarp = timeWarps[timeWarpIndex];
                        changeTimeWarpText(timeWarp + "x TimeWarp");
                    }
                } else {
                    if (partIndex > 0) {
                        partIndex--;
                        ghost.texture = id[parts[partIndex].spriteName];
                    }
                }
            }

            period.press = () => {
                if (state.name === "World") {
                    if (timeWarpIndex < timeWarps.length - 1) {
                        timeWarpIndex++;
                        timeWarp = timeWarps[timeWarpIndex];

                        if (timeWarp * 1000 > altitude) {
                            changeTimeWarpText("Cannot " + timeWarp + "x Warp at this Altitude! Go above " + timeWarp + "Km");
                            if (timeWarpIndex > 0) {
                                timeWarpIndex--;
                                timeWarp = timeWarps[timeWarpIndex];
                            }
                        } else {
                            changeTimeWarpText(timeWarp + "x TimeWarp");
                        }
                    }
                } else {
                    if (partIndex < parts.length - 1) {
                        partIndex++;
                        ghost.texture = id[parts[partIndex].spriteName];
                    }
                }
            }

            world.visible = false;
            state = VAB;
            app.ticker.add(delta => Update(delta));
        }

        function Update(delta) {
            state(delta);
        }

        // -----------------------------------------------======== Play ========----------------------------------------------- //

        function VAB(delta) {
            let COMPos = spaceRocket.worldPos(spaceRocket.COM);
            if (!isNaN(COMPos.x)) {
                COMIcon.position.set(COMPos.x, COMPos.y);
                COMIcon.visible = true;
            } else {
                COMIcon.visible = false;
            }
            //mouseGrid = worldMousePos.subtract(Vector.one.multiply(spaceRocket.container).multiply(8)).divide(16 * 8).floor()
            mouseGrid = spaceRocket.localPos(worldMousePos).floor();
            ghost.x = mouseGrid.x * 16;
            ghost.y = mouseGrid.y * 16;

            spaceRocket.parts.map(a => a.map(e => {
                if (e !== undefined) e.sprite.tint = 0xFFFFFF
            }));

            if (mouseGrid.x >= 0 && mouseGrid.x < spaceRocket.parts.length && mouseGrid.y >= 0 && mouseGrid.y < spaceRocket.parts[0].length) {
                let hoveredPart = spaceRocket.parts[mouseGrid.x][mouseGrid.y];
                if (hoveredPart !== undefined) {
                    hoveredPart.sprite.tint = 0xFF0000;
                    ghost.visible = false;
                } else {
                    ghost.visible = true;
                }
            } else {
                ghost.visible = false;
            }

        }

        function World(delta) {
            // spaceRocket.parts // check collision for each part
            // if (position.distance(planet) <= planet.radius + 12 && alive) {
            //     alive = false;
            // }
            //spaceRocket.checkCollisions();

            if (alive) {
                kerb.texture = id["Space Tilesheet 22.aseprite"];

                altitude = position.distance(planet) - planet.radius;
                if (timeWarp * 1000 > altitude) {
                    if (timeWarpIndex > 0) {
                        timeWarpIndex--;
                        timeWarp = timeWarps[timeWarpIndex];
                        changeTimeWarpText(timeWarp + "x TimeWarp");
                    }
                }
                delta *= timeWarp;

                fuelBar.outer.width = clamp(lerp(0, 200, spaceRocket.fuel / spaceRocket.fuelMax), 0, 200);

                // Inputs
                if (up.isDown) {
                    launched = true
                    if (spaceRocket.fuel > 0) {
                        if (launched) {
                            velocity.x += Math.cos(rocket.rotation - Math.PI / 2) * spaceRocket.thrust / spaceRocket.mass / 60 * delta;
                            velocity.y += Math.sin(rocket.rotation - Math.PI / 2) * spaceRocket.thrust / spaceRocket.mass / 60 * delta;
                            spaceRocket.fuel = clamp(spaceRocket.fuel - spaceRocket.thrust * delta, 0, spaceRocket.fuelMax);
                        }
                        animate(rocket, "Thrust", true, delta);
                    }
                } else {
                    //animate(rocket, "Idle", true);
                }
                if (down.isDown) {
                    angularVelocity *= (1 - brakingForce) / delta;
                }

                if (launched) {
                    if (left.isDown) {
                        angularVelocity -= rotationSpeed / spaceRocket.mass;
                    }
                    if (right.isDown) {
                        angularVelocity += rotationSpeed / spaceRocket.mass;
                    }

                    velocity = velocity.add(gravity(position).multiply(delta));

                    position.x += velocity.x * delta;
                    position.y += velocity.y * delta;
                    rocket.container.rotation += angularVelocity * delta;

                    //velocity.x *= 1-drag;
                    //velocity.y *= 1-drag;
                    angularVelocity *= 1 - drag;
                }

                rocket.container.x = position.x;
                rocket.container.y = position.y;

                if (altitude / 1000 < velocity.magnitude() * 2) {
                    if (collisionCourse && apoapsis === position) {
                        kerb.texture = id["Space Tilesheet 24.aseprite"];
                    } else {
                        kerb.texture = id["Space Tilesheet 23.aseprite"]
                    }
                }

                // If Dead
            } else {
                animate(kerb, "KIA");
                //animate(rocket, "Explosion");
                setTimeout(function() {
                    location.reload()
                }, 4000);

                if (timeWarpIndex > 0) {
                    timeWarpIndex = 0;
                    timeWarp = timeWarps[timeWarpIndex];
                    changeTimeWarpText(timeWarp + "x TimeWarp");
                }
            }

            map.alpha = clamp((zoom - mapThreshold + mapTransition / 2) / mapTransition, 0, 1)

            localMousePos = new Vector(worldMousePos.x + app.stage.pivot.x, worldMousePos.y + app.stage.pivot.y);
            var points = trajectory(position, velocity, 3000, 0.025)
                //console.log(points.length);
            trajectoryLine.updatePoints(points)
            trajectoryLine.lineWidth = zoom * 2;
            periapsisIcon.scale.set(zoom * 2);
            apoapsisIcon.scale.set(zoom * 2);

            // Camera

            app.stage.scale.set(1 / zoom);
            app.stage.pivot.x = rocket.container.position.x - innerWidth / 2 * zoom;
            app.stage.pivot.y = rocket.container.position.y - innerHeight / 2 * zoom;

            // GUI

            GUI.scale.set(zoom);
            GUI.position.set(app.stage.pivot.x, app.stage.pivot.y);

            velocityText.text = "Velocity: " + (velocity.magnitude() * 60).toFixed(2) + " M/s";
            1
            if (altitude > 1000) {
                altitudeText.text = "Altitude: " + (altitude / 1000).toFixed(3) + "Km";
            } else {
                altitudeText.text = "Altitude: " + (altitude).toFixed(2) + "M";
            }

            heading.updatePoints([Vector.zero, Vector.zero.radToVector(rocket.container.rotation - Math.PI / 2).normalized().multiply(16)]);

            timeWarpText.alpha = clamp(timeWarpText.alpha - 4 / (60 * 3 /* <-- Time to fade */ ), 0, 4);
        }

        // -----------------------------------------------======== Functions ========----------------------------------------------- //

        function trajectory(position, velocity, maxIterations, scale) {
            var points = [],
                vel = [],
                length = 0;
            fullOrbit = gravity(position).toRad() + Math.PI,
                currentAngle = 0,
                looped = false,
                playerDistance = position.distance(planet),
                lastDistance = Vector.zero,
                apoapsis = Vector.zero,
                apoapsisDistance = 0
            periapsis = Vector.zero
            periapsisDistance = 0;

            scale /= Math.pow(maxIterations, 1.5);

            points[0] = position;
            vel[0] = velocity;

            for (let i = 1; i < maxIterations; i++) {

                let gravForce = gravity(points[i - 1]);
                lastDistance = points[i - 1].distance(planet);
                length = scale * Math.pow(lastDistance, 1.5);

                if (gravForce != Vector.zero) {
                    collisionCourse = false;
                    if (currentAngle > fullOrbit) {
                        looped = true
                    }

                    if (looped && currentAngle < fullOrbit + 0.1) {
                        points[i] = position;
                        break;
                    } else {
                        currentAngle = (gravForce.toRad() + Math.PI);
                        vel[i] = vel[i - 1].add(gravForce.multiply(length));
                        points[i] = points[i - 1].add(vel[i].multiply(length));

                    }

                    var distance = points[i].distance(planet);
                    if (distance > apoapsisDistance) {
                        if (playerDistance > distance) {
                            apoapsis = position;
                        } else {
                            apoapsis = points[i];
                            apoapsisDistance = distance;
                        }
                    }
                    if (distance < periapsisDistance || periapsisDistance === 0) {
                        periapsis = points[i];
                        periapsisDistance = distance;
                    }

                } else {
                    collisionCourse = true;
                    break;
                }
            }

            apoapsisIcon.position.set(apoapsis.x, apoapsis.y);
            periapsisIcon.position.set(periapsis.x, periapsis.y);

            return points;
        }

        function lerp(start, end, percent) {
            return (1 - percent) * start + percent * end
        }

        function keyboard(value) {
            let key = {};
            key.value = value;
            key.isDown = false;
            key.isUp = true;
            key.press = undefined;
            key.release = undefined;

            // Key down handler
            key.downHandler = event => {
                if (event.key === key.value) {
                    if (key.isUp && key.press) key.press();
                    key.isDown = true;
                    key.isUp = false;
                    event.preventDefault();
                }
            };

            // Key up handler
            key.upHandler = event => {
                if (event.key === key.value) {
                    if (key.isDown && key.release) key.release();
                    key.isDown = false;
                    key.isUp = true;
                    event.preventDefault();
                }
            }

            // Attach event listeners
            const downListner = key.downHandler.bind(key);
            const upListner = key.upHandler.bind(key);


            window.addEventListener("keydown", downListner, false);
            window.addEventListener("keyup", upListner, false);

            // Detach event listners
            key.unsubscribe = () => {
                window.removeEventListener("keydown", downListner);
                window.removeEventListener("keyup", upListner);
            };

            return key;
        }

        function gravity(position) {
            let relativePosition = position.distanceTo(planet);
            let distance = relativePosition.magnitude();
            if (distance > planet.radius) {
                let direction = relativePosition.normalized();
                let gravForce = (planet.radius * 100 * 10) / (distance * distance);
                return direction.multiply(gravForce);
            } else {
                return Vector.zero;
            }
        }

        function clamp(num, min, max) {
            return num <= min ? min : num >= max ? max : num;
        }

        function changeTimeWarpText(text) {
            timeWarpText.alpha = 4;
            timeWarpText.text = text;
        }

        function animate(object, animationName, loop = false, delta = 1) {
            let animation = json.meta.frameTags.find(x => x.name === animationName);

            if (object.lastAnimation !== animationName) {
                object.frame = animation.from;
            }

            if (object.frame < animation.to + 1) {
                let spriteNumber = (object.frame - object.frame % 1)
                object.texture = id["Space Tilesheet " + spriteNumber + ".aseprite"];
                let frameDuration = json.frames["Space Tilesheet " + spriteNumber + ".aseprite"].duration;
                object.frame += 1 / (60 / delta * frameDuration / 1000)
            } else if (loop) {
                object.frame = animation.from;
            } else {
                object.frame = animation.to;
            }
            object.lastAnimation = animationName;
        }

        function createArray(length) {
            var arr = new Array(length || 0),
                i = length;

            if (arguments.length > 1) {
                var args = Array.prototype.slice.call(arguments, 1);
                while (i--) arr[length - 1 - i] = createArray.apply(this, args);
            }

            return arr;
        }

        function launch() {
            state = World;
            world.visible = true;
            VAB.visible = false;
            ghost.visible = false;
            spaceRocket.parts.map(a => a.map(e => {
                if (e !== undefined) e.tint = 0xFFFFFF
            }));
            spaceRocket.calculateProperties();
            spaceRocket.parts.map(a => a.map(e => {
                if (e !== undefined) {
                    e.x -= 24;
                    e.y -= 48;
                }
            }))
            rocket = spaceRocket;

            world.addChild(rocket.container);
            spaceRocket.position.y = -637100;
        }
    </script>
</body>

</html>