<!DOCTYPE html>
<html>

<head>
    <title>Kerbz</title>
    <script src="Pixi/pixi.min.js" type="text/javascript"></script>
</head>

<body>
    <style>
        * {
            padding: 0;
            margin: 0;
            overflow: hidden
        }
    </style>
    <!-- <script src="main.js" type="text/javascript"></script> -->
    <script>
        // -----------------------------------------------======== Classes ========----------------------------------------------- //

        class Vector {
            static zero = new Vector(0, 0);
            static one = new Vector(1, 1);
            static half = new Vector(0.5, 0.5);

            static up = new Vector(0, 1);
            static right = new Vector(1, 0);
            static down = new Vector(0, -1);
            static left = new Vector(-1, 0);

            constructor(x, y) {
                this.x = x;
                this.y = y;
            }

            // Returns the magnitude of the vector
            magnitude() {
                    return Math.sqrt(this.x * this.x + this.y * this.y);
                }
                // Returns the normalized vector (direction)
            normalized() {
                var magnitude = this.magnitude();
                if (magnitude != 0)
                    return new Vector(this.x / magnitude, this.y / magnitude);
                else
                    return 0;
            }
            floor() {
                return new Vector(Math.floor(this.x), Math.floor(this.y));
            }
            clamp(minX, minY, maxX, maxY) {
                return new Vector(clamp(this.x, minX, maxX), clamp(this.y, minY, maxY));
            }

            // Caluclates the distance from one vector to another and returns a vector
            distanceTo(target) {
                    if (typeof target === 'object') {
                        target = new Vector(target.x, target.y);
                    }
                    return new Vector(target.x - this.x, target.y - this.y)
                }
                // Calculates the direction to another vector and returns a normalized vector
            directionTo(target) {
                    if (typeof target === 'object') {
                        target = new Vector(target.x, target.y);
                    }
                    return this.distanceTo(target).normalized();
                }
                // Returns the distace to the target as a float (non directional)
            distance(target) {
                if (typeof target === 'object') {
                    target = new Vector(target.x, target.y);
                }
                return this.distanceTo(target).magnitude();
            }

            // Takes two vectors and returns their sum
            add(value) {
                    if (typeof value === 'number') {
                        value = new Vector(value, value)
                    }
                    return new Vector(this.x + value.x, this.y + value.y);
                }
                // Takes two vectors and subtracts one from the other
            subtract(value) {
                    if (typeof value === 'number') {
                        value = new Vector(value, value)
                    }
                    return new Vector(this.x - value.x, this.y - value.y);
                }
                // Takes two vectors and returns their product
            multiply(value) {
                    if (typeof value === 'number') {
                        value = new Vector(value, value)
                    }
                    return new Vector(this.x * value.x, this.y * value.y);
                }
                // Divides a vetor by by another and returns a vector
            divide(value) {
                if (typeof value === 'number') {
                    value = new Vector(value, value)
                }
                if (value.x != 0 && value.y != 0)
                    return new Vector(this.x / value.x, this.y / value.y);
                else
                    return value.zero;
            }

            // Converts an angle in radians to a vector
            radToVector(value) {
                    return new Vector(Math.cos(value), Math.sin(value));
                }
                // Converts a vector to an angle in radians
            toRad() {
                return Math.atan2(this.x, this.y);
            }
            toVector(object) {
                return new Vector(object.x, object.y);
            }
            toLocal() {
                return this.add(new Vector(app.stage.pivot.x, app.stage.pivot.y))
            }
        }

        class Line extends PIXI.Graphics {
            constructor(points, lineSize, lineColor) {
                super();

                var s = this.lineWidth = lineSize || 5;
                var c = this.lineColor = lineColor || "0x000000";

                this.points = points;

                this.lineStyle(s, c)

                this.moveTo(points[0].x, points[0].y);
                this.lineTo(points[1].x, points[1].y);
            }

            updatePoints(p) {
                var points = this.points = p.map((val, index) => val || this.points[index]);

                var s = this.lineWidth;
                var c = this.lineColor;

                this.clear();


                for (let i = 0; i < points.length - 1; i++) {
                    this.lineStyle(s, c, lerp(0.8, 0, i / (points.length - 1)));
                    this.moveTo(points[i].x, points[i].y);
                    this.lineTo(points[i + 1].x, points[i + 1].y);
                }
            }
        }

        // class Object {
        //     constructor(spriteID,
        //         position = Vector.zero,
        //         rotation = 0,
        //         velocity = Vector.zero,
        //         angularVelocity = 0,
        //         scale = 1,
        //         anchor = Vector.half) {
        //     }
        // }


        // Attachments is a bool array showing if the object can attach on a certain side [up, right, down, left]

        class Part {
            constructor(spriteName, attachments, mass) {
                this.spriteName = spriteName;
                this.attachments = attachments;
                this.mass = mass;
            }
        }

        class FuelTank extends Part {
            constructor(spriteName, attachments, mass, fuel) {
                super(spriteName, attachments, mass);
                this.fuel = fuel;
            }
        }

        class Engine extends Part {
            constructor(spriteName, attachments, mass, thrust) {
                super(spriteName, attachments, mass);
                this.thrust = thrust;
            }
        }

        class Cabin extends Part {
            constructor(spriteName, attachments, mass) {
                super(spriteName, attachments, mass);
            }
        }

        class Stage {
            constructor(parts, rootPart) {
                this.parts = parts;
                this.rootPart = rootPart;

                this.mass = 0;
                this.fuel = 0;
                this.thrust = 0;

                this.initialize();
            }

            initialize() {
                this.parts.forEach(part => {
                    this.mass += part.mass;

                    if (part.constructor.name === 'FuelTank') {
                        this.fuel += part.fuel;
                    } else if (part.constructor.name === 'Engine') {
                        this.thrust += part.thrust;
                    }
                });
            }
        }

        class Rocket {
            constructor() {
                this.parts = [
                    [3],
                    [6]
                ]; // Test this dum dum
                this.stages = [];

                this.mass = 0;
                this.fuel = 0;
                this.thrust = 0;
            }
            calculateProperties() {
                this.parts.map(y => y.map(part => {
                    if (part !== undefined) {
                        this.mass += part.mass;

                        if (part.constructor.name === 'FuelTank') {
                            this.fuel += part.fuel;
                        } else if (part.constructor.name === 'Engine') {
                            console.log("ayy")
                            this.thrust += part.thrust;
                        }
                        // console.clear()
                        // console.log(this.mass)
                        // console.log(this.thrust);
                        // console.log(this.fuel)
                    }
                }));
            }
            placePart(part, x, y) {
                if (spaceShip.elements[x][y] === undefined) {
                    let newSprite = new Sprite(id[part.spriteName]);
                    spaceShip.addChild(newSprite);
                    newSprite.position.x = x * 16;
                    newSprite.position.y = y * 16;
                    spaceShip.elements[x][y] = newSprite;
                    this.parts[x][y] = part;
                } else {
                    spaceShip.removeChild(spaceShip.elements[x][y]);
                    spaceShip.elements[x][y] = undefined;
                    this.parts[x][y] = undefined;
                }
            }
            checkCollisions() {
                spaceShip.elements.map(y => y.map(part => {
                    if (part !== undefined) {
                        const partPos = Vector.zero.toVector(part).divide(4)
                        const worldPartPos = position.add(partPos);
                        if (worldPartPos.distance(planet) <= planet.radius && alive) {
                            alive = false;
                        }
                    }
                }));
            }

        }

        // -----------------------------------------------======== PIXI ========----------------------------------------------- //

        // Preserves pixels when upscaling
        PIXI.SCALE_MODES.DEFAULT = PIXI.SCALE_MODES.NEAREST;

        // Aliases
        let Application = PIXI.Application,
            loader = PIXI.loader,
            resources = PIXI.loader.resources,
            Sprite = PIXI.Sprite,
            Text = PIXI.Text,
            TextStyle = PIXI.TextStyle;
        Graphics = PIXI.Graphics;
        Container = PIXI.Container;

        // Create a Pixi Application
        let app = new PIXI.Application({
            width: window.innerWidth,
            height: window.innerHeight,
            antialias: true,
            transparent: false,
            resolution: 1,
            forceFXAA: false,
            roundPixels: true
        });

        // Add the canvas to the HTML document
        document.body.appendChild(app.view);

        // Resize the canvas to the full page
        app.renderer.view.style.position = "absolute";
        app.renderer.view.style.display = "block";
        app.renderer.autoResize = true;
        app.renderer.resize(window.innerWidth, window.innerHeight);



        // Load an image and run the setup function when it's done
        PIXI.loader
            .add("Assets/space-spritesheet.json")
            .add("Assets/Launchpad Mockup.png")
            .load(setup);

        let left = keyboard("a"),
            right = keyboard("d"),
            up = keyboard("w"),
            down = keyboard("s");
        keyM = keyboard("m");
        comma = keyboard("q")
        period = keyboard("e");

        window.addEventListener("mousemove", e => {
            worldMousePos = new Vector(e.clientX, e.clientY)
        }, false);
        window.addEventListener("wheel", event => zoom *= 1 + event.deltaY / 5000);

        // -----------------------------------------------======== Setup ========----------------------------------------------- //

        let json;
        let request = new XMLHttpRequest();
        request.open("GET", "Assets/space-spritesheet.json", true);
        request.onload = function() {
            json = JSON.parse(this.response);
        }
        request.send();

        const drag = 0.02,
            rotationSpeed = 0.0001,
            brakingForce = 0.05;

        let vab, spaceShip, ghost, mouseGrid;

        var line, apoapsisIcon, periapsisIcon, heading, headingCircle, fuelBar, collisionCourse = false;
        var GUI, velocityText, altitudeText, fuelText, headingText, timeWarpText;
        let state, rocket, alive = true,
            launched, maxFuel = 2500,
            fuel = maxFuel,
            maxThrust = 0.4,
            thrust = maxThrust,
            altitude, planet;
        let position, velocity, angularVelocity, zoom = 0.05,
            mapThreshold = 10,
            mapTransition = 10;
        let worldMousePos = Vector.zero,
            localMousePos = Vector.zero;
        let timeWarp = 1,
            timeWarpIndex = 0,
            timeWarps = [1, 2, 5, 10, 50, 100, 500, 1000, 5000, 10000, 50000, 100000];

        let cabin = new Cabin("Space Tilesheet 27.aseprite", [0, 0, 1, 0], 0.1);
        let tank = new FuelTank("Space Tilesheet 28.aseprite", [1, 2, 1, 2], 1, 600);
        let lightweightTank = new FuelTank("Space Tilesheet 28.aseprite", [1, 2, 1, 2], 0.5, 300);
        let engine = new Engine("Space Tilesheet 29.aseprite", [1, 0, 2, 0], 1, 1);
        let partIndex = 0;
        let parts = [cabin, tank, engine];

        let stage1 = new Stage([cabin, lightweightTank, tank, tank, engine], cabin);

        let spaceRocket = new Rocket();
        spaceRocket.parts = [...Array(3)].map(e => Array(6).fill(undefined));
        spaceRocket.parts[1][1] = cabin;
        spaceRocket.parts[1][2] = lightweightTank;
        spaceRocket.parts[1][3] = tank;
        spaceRocket.parts[1][4] = tank;
        spaceRocket.parts[1][5] = engine;
        spaceRocket.stages[0] = stage1;

        //console.log(`This rocket weighs ${stage1.mass} tons, ${stage1.fuel} units of fuel and ${stage1.thrust} units of thrust`);
        // for (let i = 0; i < spaceRocket.parts[1].length; i++) {
        //     console.log(spaceRocket.parts[1][i]);
        // }

        // This will run when the image has loaded
        function setup() {

            // Create an alias called id for all the textures
            id = resources["Assets/space-spritesheet.json"].textures;

            let style = new TextStyle({
                fontFamily: "Arial",
                fontSize: 36,
                fill: "white"
            })

            // World Container
            world = new Container();
            app.stage.addChild(world);

            state = World
            app.ticker.add(delta => Update(delta));
        }

        function Update(delta) {
            state(delta);
        }

        // -----------------------------------------------======== Play ========----------------------------------------------- //

        function World(delta) {

        }

        // -----------------------------------------------======== Functions ========----------------------------------------------- //

        function lerp(start, end, percent) {
            return (1 - percent) * start + percent * end
        }

        function keyboard(value) {
            let key = {};
            key.value = value;
            key.isDown = false;
            key.isUp = true;
            key.press = undefined;
            key.release = undefined;

            // Key down handler
            key.downHandler = event => {
                if (event.key === key.value) {
                    if (key.isUp && key.press) key.press();
                    key.isDown = true;
                    key.isUp = false;
                    event.preventDefault();
                }
            };

            // Key up handler
            key.upHandler = event => {
                if (event.key === key.value) {
                    if (key.isDown && key.release) key.release();
                    key.isDown = false;
                    key.isUp = true;
                    event.preventDefault();
                }
            }

            // Attach event listeners
            const downListner = key.downHandler.bind(key);
            const upListner = key.upHandler.bind(key);


            window.addEventListener("keydown", downListner, false);
            window.addEventListener("keyup", upListner, false);

            // Detach event listners
            key.unsubscribe = () => {
                window.removeEventListener("keydown", downListner);
                window.removeEventListener("keyup", upListner);
            };

            return key;
        }

        function clamp(num, min, max) {
            return num <= min ? min : num >= max ? max : num;
        }

        function animate(object, animationName, loop = false, delta = 1) {
            let animation = json.meta.frameTags.find(x => x.name === animationName);

            if (object.lastAnimation !== animationName) {
                object.frame = animation.from;
            }

            if (object.frame < animation.to + 1) {
                let spriteNumber = (object.frame - object.frame % 1)
                object.texture = id["Space Tilesheet " + spriteNumber + ".aseprite"];
                let frameDuration = json.frames["Space Tilesheet " + spriteNumber + ".aseprite"].duration;
                object.frame += 1 / (60 / delta * frameDuration / 1000)
            } else if (loop) {
                object.frame = animation.from;
            } else {
                object.frame = animation.to;
            }
            object.lastAnimation = animationName;
        }

        function createArray(length) {
            var arr = new Array(length || 0),
                i = length;

            if (arguments.length > 1) {
                var args = Array.prototype.slice.call(arguments, 1);
                while (i--) arr[length - 1 - i] = createArray.apply(this, args);
            }

            return arr;
        }
    </script>
</body>

</html>